# 更优方案分析

## 当前方案 vs 更优方案对比

### 当前方案（智能轮询 + 缓存）

**优点**：
- ✅ 纯JavaScript实现，无需原生代码
- ✅ 易于维护和调试
- ✅ 跨平台兼容性好
- ✅ 已实现，立即可用

**缺点**：
- ❌ 仍然需要轮询（即使智能调整）
- ❌ 有延迟（最快2秒响应）
- ❌ 需要执行系统命令（mount、diskutil等）
- ❌ CPU使用率虽然降低，但仍需定期检测

---

## 🚀 方案1：事件驱动（推荐）

### 核心思路
使用 macOS 系统事件监听设备插拔，**完全消除轮询**。

### 实现方式

#### 1.1 使用 `diskutil` 事件监听（最简单）

```typescript
// 使用 diskutil 的监控功能
import { spawn } from 'child_process';

class EventDrivenDetector {
  private monitorProcess: any = null;

  startMonitoring(callback: (devices: NTFSDevice[]) => void) {
    // 使用 diskutil list 的监控模式
    // 或者使用 fswatch 监控 /Volumes 目录
    this.monitorProcess = spawn('fswatch', [
      '-o',  // 只输出事件数量
      '/Volumes'
    ]);

    this.monitorProcess.stdout.on('data', async () => {
      // 目录变化，立即检测设备
      const devices = await this.detectDevices();
      callback(devices);
    });
  }

  stopMonitoring() {
    if (this.monitorProcess) {
      this.monitorProcess.kill();
    }
  }
}
```

**优点**：
- ✅ **零延迟**：设备插拔立即响应
- ✅ **零CPU**：无轮询，只在事件时执行
- ✅ **实现简单**：使用现有工具（fswatch）
- ✅ **电池友好**：几乎不消耗资源

**缺点**：
- ❌ 需要安装 fswatch（可通过 Homebrew）
- ❌ 只能检测挂载点变化，不能检测设备状态变化

#### 1.2 使用 Electron 的 native 模块（更强大）

```typescript
// 使用 node-ffi-napi 或 node-addon-api 调用 macOS API
import { IOKit } from './native/iokit-binding';

class IOKitDetector {
  private notificationPort: any;

  async startMonitoring(callback: (event: DeviceEvent) => void) {
    // 使用 IOKit 框架监听设备插拔
    this.notificationPort = IOKit.createNotificationPort();

    IOKit.registerForDeviceChanges(this.notificationPort, (event) => {
      if (event.type === 'deviceAdded' || event.type === 'deviceRemoved') {
        callback(event);
      }
    });
  }
}
```

**优点**：
- ✅ **真正的实时响应**：系统级事件
- ✅ **最省资源**：系统原生支持
- ✅ **可获取详细信息**：设备类型、容量等

**缺点**：
- ❌ 需要编写原生代码（Swift/Objective-C）
- ❌ 需要编译原生模块
- ❌ 跨平台兼容性差

---

## 🎯 方案2：混合方案（最佳实践）

### 核心思路
**事件驱动 + 智能轮询备用**

```typescript
class HybridDetector {
  private eventDetector: EventDrivenDetector;
  private pollingManager: SmartPollingManager;
  private useEvents: boolean = false;

  async initialize() {
    // 尝试使用事件驱动
    try {
      await this.eventDetector.startMonitoring();
      this.useEvents = true;
      console.log('✅ 使用事件驱动模式');
    } catch (error) {
      // 降级到智能轮询
      this.useEvents = false;
      this.pollingManager.start();
      console.log('⚠️ 降级到智能轮询模式');
    }
  }

  // 统一接口
  onDeviceChange(callback: (devices: NTFSDevice[]) => void) {
    if (this.useEvents) {
      this.eventDetector.onChange(callback);
    } else {
      this.pollingManager.onChange(callback);
    }
  }
}
```

**优点**：
- ✅ **最佳性能**：优先使用事件，降级到轮询
- ✅ **高可用性**：即使事件失败也能工作
- ✅ **渐进增强**：逐步优化

---

## 🔧 方案3：原生模块方案

### 核心思路
使用 Swift/Objective-C 编写原生模块，直接调用 macOS API。

### 实现架构

```
Electron App (TypeScript)
    ↓ IPC
Native Module (Swift)
    ↓
IOKit Framework
    ↓
macOS System
```

### 代码示例

**Swift 原生模块**：
```swift
import IOKit
import Foundation

@objc public class NTFSDeviceMonitor: NSObject {
    private var notificationPort: IONotificationPortRef?

    @objc public func startMonitoring(callback: @escaping (String) -> Void) {
        // 使用 IOKit 监听设备插拔
        let matching = IOServiceMatching("IOMediaBSDClient")
        notificationPort = IONotificationPortCreate(kIOMasterPortDefault)

        var iterator: io_iterator_t = 0
        IOServiceAddMatchingNotification(
            notificationPort,
            kIOMatchedNotification,
            matching,
            deviceAddedCallback,
            &iterator,
            &iterator
        )

        // 处理初始设备
        processDevices(iterator: iterator, callback: callback)
    }
}
```

**TypeScript 绑定**：
```typescript
// 使用 node-addon-api
import { NativeAddon } from './native/addon';

const monitor = new NativeAddon.NTFSDeviceMonitor();
monitor.startMonitoring((event) => {
  // 设备插拔事件
  handleDeviceEvent(event);
});
```

**优点**：
- ✅ **性能最优**：直接调用系统API
- ✅ **功能最全**：可获取所有设备信息
- ✅ **资源最少**：系统级优化

**缺点**：
- ❌ **开发复杂**：需要原生开发知识
- ❌ **维护成本高**：需要处理不同macOS版本
- ❌ **构建复杂**：需要Xcode和编译工具链

---

## 📊 方案对比表

| 方案 | 响应速度 | CPU使用 | 实现难度 | 维护成本 | 推荐度 |
|------|---------|---------|----------|----------|--------|
| **当前方案**（智能轮询） | 2-30秒 | 1-3% | ⭐ 简单 | ⭐ 低 | ⭐⭐⭐ |
| **方案1.1**（fswatch事件） | **即时** | **<0.1%** | ⭐⭐ 中等 | ⭐⭐ 中 | ⭐⭐⭐⭐⭐ |
| **方案1.2**（IOKit事件） | **即时** | **<0.1%** | ⭐⭐⭐⭐ 困难 | ⭐⭐⭐ 高 | ⭐⭐⭐⭐ |
| **方案2**（混合方案） | **即时/2秒** | **<0.1%/1-3%** | ⭐⭐⭐ 中等 | ⭐⭐ 中 | ⭐⭐⭐⭐⭐ |
| **方案3**（原生模块） | **即时** | **<0.1%** | ⭐⭐⭐⭐⭐ 很困难 | ⭐⭐⭐⭐ 很高 | ⭐⭐⭐ |

---

## 🎯 推荐方案：方案1.1（fswatch事件驱动）

### 为什么推荐？

1. **性能最优**：
   - 零延迟响应
   - CPU使用 < 0.1%
   - 电池续航最佳

2. **实现简单**：
   - 只需安装 fswatch：`brew install fswatch`
   - 纯 TypeScript 实现
   - 无需原生代码

3. **维护成本低**：
   - 使用成熟工具（fswatch）
   - 代码简单易懂
   - 易于调试

### 实现步骤

#### 步骤1：安装依赖
```bash
brew install fswatch
```

#### 步骤2：创建事件驱动检测器
```typescript
// src/scripts/ntfs-manager/event-driven-detector.ts
import { spawn, ChildProcess } from 'child_process';
import { DeviceDetector } from './device-detector';

export class EventDrivenDetector {
  private fswatchProcess: ChildProcess | null = null;
  private deviceDetector: DeviceDetector;
  private onChangeCallback?: (devices: any[]) => void;
  private debounceTimer: NodeJS.Timeout | null = null;

  constructor(deviceDetector: DeviceDetector) {
    this.deviceDetector = deviceDetector;
  }

  async start(callback: (devices: any[]) => void): Promise<boolean> {
    try {
      // 检查 fswatch 是否可用
      await this.checkFswatch();

      this.onChangeCallback = callback;

      // 启动 fswatch 监控 /Volumes 目录
      this.fswatchProcess = spawn('fswatch', [
        '-o',           // 只输出事件数量
        '-1',           // 只监听一次（配合循环使用）
        '/Volumes'
      ]);

      // 监听输出
      this.fswatchProcess.stdout?.on('data', () => {
        this.handleVolumeChange();
      });

      this.fswatchProcess.stderr?.on('data', (data) => {
        console.error('[fswatch] 错误:', data.toString());
      });

      this.fswatchProcess.on('close', (code) => {
        if (code !== 0 && code !== null) {
          console.warn('[fswatch] 进程退出，代码:', code);
        }
        // 自动重启（如果进程意外退出）
        if (this.onChangeCallback) {
          setTimeout(() => this.start(this.onChangeCallback!), 1000);
        }
      });

      console.log('✅ 事件驱动检测已启动');
      return true;
    } catch (error) {
      console.error('❌ 事件驱动检测启动失败:', error);
      return false;
    }
  }

  private async checkFswatch(): Promise<void> {
    return new Promise((resolve, reject) => {
      const check = spawn('which', ['fswatch']);
      check.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('fswatch 未安装，请运行: brew install fswatch'));
        }
      });
    });
  }

  private async handleVolumeChange(): Promise<void> {
    // 防抖：200ms内多次事件只处理一次
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = setTimeout(async () => {
      try {
        const devices = await this.deviceDetector.getNTFSDevices();
        if (this.onChangeCallback) {
          this.onChangeCallback(devices);
        }
      } catch (error) {
        console.error('处理设备变化失败:', error);
      }
    }, 200);
  }

  stop(): void {
    if (this.fswatchProcess) {
      this.fswatchProcess.kill();
      this.fswatchProcess = null;
    }
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
    this.onChangeCallback = undefined;
  }
}
```

#### 步骤3：集成到主检测逻辑
```typescript
// 修改 device-detector.ts 或创建新的管理器
class DeviceDetectionManager {
  private eventDetector: EventDrivenDetector;
  private pollingManager: SmartPollingManager;
  private useEvents: boolean = false;

  async initialize(deviceDetector: DeviceDetector) {
    this.eventDetector = new EventDrivenDetector(deviceDetector);
    this.pollingManager = new SmartPollingManager();

    // 尝试使用事件驱动
    const eventSuccess = await this.eventDetector.start((devices) => {
      this.onDeviceChange(devices);
    });

    if (!eventSuccess) {
      // 降级到智能轮询
      this.pollingManager.start(async () => {
        const devices = await deviceDetector.getNTFSDevices();
        this.onDeviceChange(devices);
      });
    }

    this.useEvents = eventSuccess;
  }
}
```

---

## 🚀 方案4：使用 macOS Workspace API（高级）

### 核心思路
通过 Electron 的 native 模块调用 NSWorkspace，监听卷挂载事件。

**优点**：
- ✅ 系统原生支持
- ✅ 可获取详细挂载信息
- ✅ 性能最优

**缺点**：
- ❌ 需要原生代码
- ❌ 需要编译

---

## 💡 最终推荐

### 短期（立即实施）
**方案1.1：fswatch事件驱动**
- 实现简单
- 性能最优
- 维护成本低

### 长期（未来优化）
**方案2：混合方案**
- 事件驱动 + 智能轮询备用
- 最佳用户体验
- 高可用性

### 如果追求极致性能
**方案3：原生模块**
- 需要投入更多开发资源
- 适合长期维护的项目

---

## 📝 实施建议

1. **先实施方案1.1**（fswatch事件驱动）
   - 快速见效
   - 风险低
   - 可立即提升性能

2. **保留智能轮询作为备用**
   - 如果 fswatch 不可用
   - 作为降级方案

3. **逐步优化**
   - 先验证事件驱动效果
   - 再考虑原生模块（如果需要）

---

## 🎯 性能提升预期

| 指标 | 当前方案 | fswatch事件 | 提升 |
|------|---------|------------|------|
| 响应速度 | 2-30秒 | **即时** | **100%** |
| CPU使用（空闲） | 1-3% | **<0.1%** | **90%+** |
| 电池续航 | 基准 | **+30-50%** | **显著提升** |
| 系统命令调用 | 定期执行 | **仅事件时** | **95%+** |

---

## 总结

**最佳方案：fswatch事件驱动（方案1.1）**

- ✅ 性能最优（零延迟，零CPU）
- ✅ 实现简单（纯TypeScript）
- ✅ 维护成本低
- ✅ 可立即实施

**备选方案：混合方案（方案2）**

- ✅ 高可用性
- ✅ 渐进增强
- ✅ 最佳用户体验
