// NTFS设备页面脚本
(function() {
  'use strict';

  // 检查 electronAPI 是否已存在
  if (typeof window.electronAPI === 'undefined') {
    console.error('electronAPI 未定义，请检查 preload.js 是否正确加载');
    window.electronAPI = {} as any;
  }

  const electronAPI = window.electronAPI;

  // DOM 元素
  const devicesList = document.getElementById('devicesList')!;
  const loadingOverlay = document.getElementById('loadingOverlay') as HTMLElement;
  const autoMountBtn = document.getElementById('autoMountBtn') as HTMLButtonElement | null;
  const showMainWindowBtn = document.getElementById('showMainWindowBtn') as HTMLButtonElement | null;
  const refreshDevicesBtn = document.getElementById('refreshDevicesBtn') as HTMLButtonElement | null;
  const mountAllBtn = document.getElementById('mountAllBtn') as HTMLButtonElement | null;
  const restoreAllReadOnlyBtn = document.getElementById('restoreAllReadOnlyBtn') as HTMLButtonElement | null;
  const ejectAllBtn = document.getElementById('ejectAllBtn') as HTMLButtonElement | null;

  // 状态管理
  let devices: any[] = [];
  let autoRefreshInterval: NodeJS.Timeout | null = null;
  let lastDeviceCount = 0;
  let lastDeviceState = '';
  let hybridDetectionStarted: boolean = false;

  type LogType = 'info' | 'success' | 'error' | 'warning';

  // 获取翻译文本的辅助函数
  function t(key: string, params?: Record<string, string | number>): string {
    const AppUtils = (window as any).AppUtils;
    if (AppUtils && AppUtils.I18n && AppUtils.I18n.t) {
      return AppUtils.I18n.t(key, params);
    }
    // 如果 i18n 未初始化，返回 key
    return key;
  }

  // 格式化容量显示
  function formatCapacity(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(1)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  // 添加日志
  function addLog(message: string, type: LogType = 'info'): void {
    const time = new Date().toLocaleTimeString('zh-CN');
    const logs = JSON.parse(localStorage.getItem('appLogs') || '[]');
    logs.push({ time, message, type });
    // 限制日志数量
    if (logs.length > 1000) {
      logs.shift();
    }
    localStorage.setItem('appLogs', JSON.stringify(logs));
  }

  // 显示/隐藏加载遮罩
  function showLoading(show: boolean = true): void {
    if (show) {
      loadingOverlay.classList.add('visible');
    } else {
      loadingOverlay.classList.remove('visible');
    }
  }

  // 刷新设备列表（优化版：防抖和增量更新）
  let refreshDebounceTimer: number | null = null;
  const REFRESH_DEBOUNCE_MS = 200; // 防抖200ms

  async function refreshDevices(force: boolean = false): Promise<void> {
    // 防抖：短时间内多次调用只执行最后一次
    if (!force && refreshDebounceTimer !== null) {
      clearTimeout(refreshDebounceTimer);
    }

    const doRefresh = async () => {
      try {
        const oldDevices = [...devices];
        devices = await electronAPI.getNTFSDevices();

        // 增量更新：只更新变化的部分
        const hasChanged = JSON.stringify(oldDevices.map(d => ({ disk: d.disk, isMounted: d.isMounted }))) !==
                          JSON.stringify(devices.map(d => ({ disk: d.disk, isMounted: d.isMounted })));

        if (hasChanged || force) {
          renderDevices();
        }

        const currentDeviceCount = devices.length;

      // 如果是托盘窗口，根据设备数量调整窗口高度
      if (document.body && document.body.classList.contains('tray-window')) {
        // 延迟执行，确保 DOM 已完全渲染
        setTimeout(async () => {
          try {
            console.log('[设备列表更新] 设备数量:', currentDeviceCount, '准备调整窗口高度');
            if (electronAPI.adjustTrayWindowHeightByDeviceCount) {
              await electronAPI.adjustTrayWindowHeightByDeviceCount(currentDeviceCount);
            } else {
              console.warn('[设备列表更新] adjustTrayWindowHeightByDeviceCount API 不存在');
            }
          } catch (error) {
            console.error('[设备列表更新] 调整窗口高度失败:', error);
          }
        }, 150);
      }
      const readOnlyCount = devices.filter(d => d.isReadOnly).length;
      const currentState = `${currentDeviceCount}-${readOnlyCount}`;

      // 只在设备状态变化时添加日志
      const stateChanged = currentDeviceCount !== lastDeviceCount || currentState !== lastDeviceState;

      if (devices.length === 0) {
        if (stateChanged) {
          addLog(t('messages.noDevicesDetected'), 'info');
        }
      } else {
        const readWriteCount = devices.length - readOnlyCount;

        if (readOnlyCount > 0) {
          if (stateChanged) {
            if (readWriteCount > 0) {
              addLog(t('messages.devicesDetected', { count: devices.length, readOnly: readOnlyCount, readWrite: readWriteCount }), 'info');
            } else {
              addLog(t('messages.devicesDetectedAllReadOnly', { count: devices.length }), 'warning');
            }
          }
        } else {
          if (stateChanged) {
            addLog(t('messages.devicesDetectedAllReadWrite', { count: devices.length }), 'success');
          }
        }
      }

        lastDeviceCount = currentDeviceCount;
        lastDeviceState = currentState;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        addLog(t('messages.refreshFailed', { error: errorMessage }), 'error');
      } finally {
        showLoading(false);
      }
    };

    if (!force) {
      refreshDebounceTimer = window.setTimeout(doRefresh, REFRESH_DEBOUNCE_MS);
    } else {
      doRefresh();
    }
  }

  // 渲染设备列表
  function renderDevices(): void {
    if (devices.length === 0) {
      devicesList.innerHTML = `
        <div class="empty-state">
          <div class="empty-icon"></div>
          <p>${t('devices.emptyState')}</p>
          <p class="empty-hint">${t('devices.emptyHint')}</p>
        </div>
      `;
      return;
    }

    // 保存当前选中的设备（如果有）
    const selectedDisk = (document.querySelector('.device-item.selected') as HTMLElement)?.dataset?.disk;

    // 检查是否是托盘窗口（用于判断是否需要重新渲染）
    const isTrayWindow = document.body && document.body.classList.contains('tray-window');
    const lastIsTrayWindow = (devicesList as any).__lastIsTrayWindow;

    // 生成设备状态的唯一标识，用于判断是否需要更新
    // 包含容量信息，确保容量变化时能触发重新渲染
    const deviceStateKey = devices.map(d => {
      const capacityInfo = d.capacity ? `${d.capacity.total}:${d.capacity.available || 0}:${d.capacity.used || 0}` : 'no-capacity';
      return `${d.disk}:${d.isReadOnly}:${d.isUnmounted}:${capacityInfo}`;
    }).join('|');
    const lastStateKey = (devicesList as any).__lastStateKey || '';

    // 如果设备状态没有变化，且窗口类型没有变化，且已有DOM元素，则跳过重新渲染
    if (deviceStateKey === lastStateKey &&
        isTrayWindow === lastIsTrayWindow &&
        devicesList.querySelectorAll('.device-item').length === devices.length) {
      return;
    }

    // 保存当前窗口类型
    (devicesList as any).__lastIsTrayWindow = isTrayWindow;

    (devicesList as any).__lastStateKey = deviceStateKey;

    devicesList.innerHTML = '';

    devices.forEach(device => {
      const item = document.createElement('div');
      item.className = 'device-item';
      item.setAttribute('data-disk', device.disk);

      // 添加读写设备样式类
      if (!device.isReadOnly && !device.isUnmounted) {
        item.classList.add('read-write-device');
      }
      if (device.isUnmounted) {
        item.classList.add('unmounted-device');
      }

      const isUnmounted = device.isUnmounted || false;
      const statusClass = isUnmounted ? 'unmounted' : (device.isReadOnly ? 'read-only' : 'read-write');
      const statusText = isUnmounted ? t('devices.unmounted') : (device.isReadOnly ? t('devices.readOnly') : t('devices.readWrite'));

      // 检查是否是托盘窗口
      const isTrayWindow = document.body.classList.contains('tray-window');

      // 计算容量百分比和使用空间（Windows 风格）
      let capacityPercent = 0;
      let availableText = '';
      let totalText = '';

      // 调试：检查原始数据
      if (!device.capacity) {
        console.warn('设备没有容量数据:', device.volumeName, device);
      }

      if (device.capacity && device.capacity.total > 0) {
        const total = device.capacity.total;
        let used = device.capacity.used || 0;
        let available = device.capacity.available || 0;

        // 调试：输出原始数据
        console.log('设备原始容量数据:', device.volumeName, {
          total: total,
          originalUsed: used,
          originalAvailable: available,
          totalFormatted: formatCapacity(total),
          usedFormatted: formatCapacity(used),
          availableFormatted: formatCapacity(available)
        });

        // 计算逻辑：始终优先使用 available 来计算 used（更可靠）
        // 因为 available 通常比 used 更准确，且不容易出错
        // 注意：即使 available 接近 total（比如 99.9%），也应该使用它来计算
        if (available > 0) {
          // 如果 available 存在，直接使用它来计算 used
          // 这是最可靠的方法，因为 available 通常更准确
          used = total - available;
          // 确保 used 不为负数
          if (used < 0) {
            used = 0;
            available = total;
          }
        } else if (device.capacity.used && device.capacity.used > 0) {
          // 如果只有 used 值（available 不存在或无效），使用它
          used = device.capacity.used;
          available = total - used;
          if (available < 0) {
            available = 0;
            used = total;
          }
        } else {
          // 如果都无法获取，至少显示总容量
          used = 0;
          available = total;
        }

        // 最终验证：确保 used + available 约等于 total
        const sum = used + available;
        const diff = Math.abs(sum - total);
        if (diff > total * 0.01) {
          // 如果差异超过 1%，重新计算
          if (available > 0 && available < total) {
            used = total - available;
          } else if (used > 0 && used < total) {
            available = total - used;
          }
        }

        // 确保数据不为负数且不超过 total
        used = Math.max(0, Math.min(total, used));
        available = Math.max(0, Math.min(total, available));

        // 计算使用率百分比（用于进度条和颜色）
        // 确保百分比在 0-100 之间
        // 使用更精确的计算，避免浮点数精度问题
        let rawPercent = 0;
        if (total > 0) {
          rawPercent = (used / total) * 100;
          // 先四舍五入到整数，确保百分比是整数
          capacityPercent = Math.max(0, Math.min(100, Math.round(rawPercent)));

          // 如果计算结果异常，重新计算
          if (isNaN(capacityPercent) || capacityPercent < 0 || capacityPercent > 100) {
            console.error('容量百分比计算异常，重新计算:', device.volumeName, {
              used,
              total,
              available,
              rawPercent,
              capacityPercent
            });
            capacityPercent = Math.max(0, Math.min(100, Math.round((used / total) * 100)));
          }
        } else {
          capacityPercent = 0;
          rawPercent = 0;
        }

        // 调试：输出计算后的数据
        console.log('设备容量计算结果:', device.volumeName, {
          total: formatCapacity(total),
          used: formatCapacity(used),
          available: formatCapacity(available),
          percent: capacityPercent + '%',
          rawPercent: rawPercent.toFixed(2) + '%',
          raw: {
            total,
            used,
            available,
            usedBytes: used,
            totalBytes: total,
            calculatedUsed: total - available,
            calculatedPercent: ((total - available) / total * 100).toFixed(2) + '%'
          },
          // 添加进度条渲染信息
          progressBarWidth: capacityPercent + '%',
          willRender: device.capacity && device.capacity.total > 0 && availableText && totalText
        });

        availableText = formatCapacity(available);
        totalText = formatCapacity(total);
        item.setAttribute('data-capacity-percent', capacityPercent.toString());

        // 最终验证：确保 capacityPercent 正确计算
        if (capacityPercent < 0 || capacityPercent > 100 || isNaN(capacityPercent)) {
          console.error('设备容量百分比计算错误:', device.volumeName, {
            capacityPercent,
            used,
            total,
            available,
            rawPercent: total > 0 ? (used / total) * 100 : 0
          });
          // 重新计算
          if (total > 0) {
            capacityPercent = Math.max(0, Math.min(100, Math.round((used / total) * 100)));
          } else {
            capacityPercent = 0;
          }
        }
      } else {
        console.warn('设备容量数据无效:', device.volumeName, {
          hasCapacity: !!device.capacity,
          total: device.capacity?.total,
          used: device.capacity?.used,
          available: device.capacity?.available
        });
      }

      // 托盘窗口使用卡片样式，主窗口使用原来的样式
      // 在渲染前再次验证 capacityPercent（防止变量作用域问题）
      let finalCapacityPercent = capacityPercent;
      if (isTrayWindow) {
        if (device.capacity && device.capacity.total > 0) {
          const total = device.capacity.total;
          const available = device.capacity.available || 0;
          const used = device.capacity.used || 0;
          let calculatedUsed = used;

          // 重新计算以确保正确
          if (available > 0) {
            calculatedUsed = total - available;
          } else if (used > 0) {
            calculatedUsed = used;
          }

          if (total > 0 && calculatedUsed >= 0) {
            const recalculatedPercent = Math.round((calculatedUsed / total) * 100);
            finalCapacityPercent = Math.max(0, Math.min(100, recalculatedPercent));

            // 如果重新计算的值与原来的不同，输出警告
            if (finalCapacityPercent !== capacityPercent) {
              console.warn(`[容量百分比不一致] ${device.volumeName}: 原值=${capacityPercent}%, 重新计算=${finalCapacityPercent}%`, {
                original: capacityPercent,
                recalculated: finalCapacityPercent,
                total,
                available,
                used,
                calculatedUsed
              });
            }
          }
        }

        // 托盘窗口：显示磁盘名称、容量条和操作按钮
        item.innerHTML = `
          <div class="device-card-tray">
            <div class="device-icon-large">
              <img src="../imgs/ico/drive.svg" alt="${device.volumeName}" class="device-icon-svg">
            </div>
            <div class="device-card-content">
              <div class="device-name-large">${device.volumeName}</div>
              ${device.capacity && device.capacity.total > 0 && availableText && totalText ? `
              <div class="device-capacity-info-windows">
                <span class="capacity-text-windows">${availableText} ${t('devices.available')}, ${t('devices.total')} ${totalText}</span>
              </div>
              <div class="capacity-bar-windows">
                <div class="capacity-bar-fill-windows" data-percent="${finalCapacityPercent}" data-width="${finalCapacityPercent}" title="${t('devices.usageRate')}: ${finalCapacityPercent}%"></div>
              </div>
              ` : ''}
              <div class="device-actions-tray">
                ${isUnmounted ? `
                  <button class="btn btn-success mount-btn" data-disk="${device.disk}">
                    ${t('devices.remount')}
                  </button>
                  <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                    ${t('devices.eject')}
                  </button>
                ` : device.isReadOnly ? `
                  <button class="btn btn-success mount-btn" data-disk="${device.disk}">
                    ${t('devices.mount')}
                  </button>
                  <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                    ${t('devices.eject')}
                  </button>
                ` : `
                  <button class="btn btn-secondary restore-readonly-btn" data-disk="${device.disk}">
                    ${t('devices.restoreReadOnly')}
                  </button>
                  <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                    ${t('devices.eject')}
                  </button>
                `}
              </div>
            </div>
          </div>
        `;
      } else {
        item.innerHTML = `
          <div class="device-header">
            <div class="device-name">
              <span class="device-icon"></span>
              ${device.volumeName}
            </div>
            <span class="device-status ${statusClass}">${statusText}</span>
          </div>
          <div class="device-info">
            ${(() => {
              // 优先使用共享的设备信息渲染函数（如果存在），避免重复代码
              const AppModules = (window as any).AppModules;
              if (AppModules && AppModules.Devices && AppModules.Devices.Utils && AppModules.Devices.Utils.renderDeviceInfoHTML) {
                return AppModules.Devices.Utils.renderDeviceInfoHTML(device, t, formatCapacity);
              }
              // 如果共享函数不存在，使用本地实现（向后兼容）
              return `
                ${device.capacity ? `
                <div class="device-info-item">
                  <span class="device-info-label">${t('devices.capacityLabel')}</span>
                  <span>${formatCapacity(device.capacity.used)}/${formatCapacity(device.capacity.total)}</span>
                </div>
                ` : ''}
                <div class="device-info-item">
                  <span class="device-info-label">${t('devices.deviceMountPointLabel')}</span>
                  <span>${device.devicePath}${isUnmounted ? ` (${t('devices.notMounted')})` : ` → ${device.volume}`}</span>
                </div>
              `;
            })()}
          </div>
        `;
      }

      // 只在主窗口添加操作按钮，托盘窗口不显示
      if (!isTrayWindow) {
        const actionsHTML = `
          <div class="device-actions">
            ${isUnmounted ? `
              <button class="btn btn-success mount-btn" data-disk="${device.disk}">
                ${t('devices.remount')}
              </button>
              <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                ${t('devices.eject')}
              </button>
            ` : device.isReadOnly ? `
              <button class="btn btn-success mount-btn" data-disk="${device.disk}">
                ${t('devices.mount')}
              </button>
              <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                ${t('devices.eject')}
              </button>
            ` : `
              <button class="btn btn-secondary restore-readonly-btn" data-disk="${device.disk}">
                ${t('devices.restoreReadOnly')}
              </button>
              <button class="btn btn-danger eject-btn" data-disk="${device.disk}">
                ${t('devices.eject')}
              </button>
            `}
          </div>
        `;

        item.innerHTML += actionsHTML;
      }

      devicesList.appendChild(item);

      // 渲染后立即设置进度条宽度（避免 CSP 阻止内联样式）
      if (isTrayWindow && device.capacity && device.capacity.total > 0) {
        // 使用 setTimeout 确保 DOM 已渲染
        setTimeout(() => {
          const fillElement = item.querySelector('.capacity-bar-fill-windows') as HTMLElement;
          if (fillElement) {
            // 通过 JavaScript 设置样式不会被 CSP 阻止
            const percent = fillElement.getAttribute('data-width');
            if (percent) {
              fillElement.style.width = `${percent}%`;

              // 调试信息
              const finalPercent = fillElement.getAttribute('data-width') || '0';
              console.log(`[设置进度条宽度] ${device.volumeName}:`, {
                percent: percent + '%',
                calculatedPercent: capacityPercent + '%',
                finalCapacityPercent: finalPercent + '%',
                computedStyle: window.getComputedStyle(fillElement).width,
                parentWidth: window.getComputedStyle(fillElement.parentElement as HTMLElement).width
              });
            }
          }
        }, 0);
      }
    });

    // 恢复选中状态
    if (selectedDisk) {
      const selectedItem = devicesList.querySelector(`[data-disk="${selectedDisk}"]`) as HTMLElement;
      if (selectedItem) {
        selectedItem.classList.add('selected');
      }
    }

    // 绑定按钮事件
    devicesList.querySelectorAll('.mount-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const disk = (btn as HTMLElement).dataset.disk;
        const device = devices.find(d => d.disk === disk);
        if (device) mountDevice(device);
      });
    });

    devicesList.querySelectorAll('.restore-readonly-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const disk = (btn as HTMLElement).dataset.disk;
        const device = devices.find(d => d.disk === disk);
        if (device) restoreToReadOnly(device);
      });
    });

    devicesList.querySelectorAll('.eject-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const disk = (btn as HTMLElement).dataset.disk;
        const device = devices.find(d => d.disk === disk);
        if (device) ejectDevice(device);
      });
    });
  }

  // 挂载设备（配置为可读写）
  async function mountDevice(device: any): Promise<void> {
    try {
      showLoading(true);
      addLog(t('messages.mounting', { name: device.volumeName }), 'info');
      addLog(t('messages.enterPassword'), 'info');

      const result = await electronAPI.mountDevice(device);

      if (result.success) {
        if (result.result) {
          addLog(result.result, 'success');
        }
        // 等待一小段时间，确保挂载操作完全完成
        await new Promise(resolve => setTimeout(resolve, 500));
        await refreshDevices();
      } else {
        addLog(`${t('messages.mountError')}: ${result.error || t('messages.unknownError')}`, 'error');
        if (result.error?.includes('密码错误') || result.error?.includes('password')) {
          addLog(t('messages.passwordError'), 'warning');
        } else if (result.error?.includes('用户取消') || result.error?.includes('cancel')) {
          addLog(t('messages.cancelled'), 'info');
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.mountError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 还原为只读
  async function restoreToReadOnly(device: any): Promise<void> {
    try {
      showLoading(true);
      addLog(t('messages.restoring', { name: device.volumeName }), 'info');
      addLog(t('messages.enterPassword'), 'info');

      const result = await electronAPI.restoreToReadOnly(device);

      if (result.success) {
        if (result.result) {
          addLog(result.result, 'success');
        }
        // restoreToReadOnly需要等待系统重新挂载
        setTimeout(async () => {
          await refreshDevices();
        }, 2000);
      } else {
        addLog(`${t('messages.restoreError')}: ${result.error || t('messages.unknownError')}`, 'error');
        if (result.error?.includes('密码错误') || result.error?.includes('password')) {
          addLog(t('messages.passwordError'), 'warning');
        } else if (result.error?.includes('用户取消') || result.error?.includes('cancel')) {
          addLog(t('messages.cancelled'), 'info');
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.restoreError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 推出设备
  async function ejectDevice(device: any): Promise<void> {
    try {
      showLoading(true);
      addLog(t('messages.ejecting', { name: device.volumeName }), 'info');
      addLog(t('messages.enterPassword'), 'info');

      const result = await electronAPI.ejectDevice(device);

      if (result.success) {
        if (result.result) {
          addLog(result.result, 'success');
        }
        await refreshDevices();
      } else {
        addLog(`${t('messages.ejectError')}: ${result.error || t('messages.unknownError')}`, 'error');
        if (result.error?.includes('密码错误') || result.error?.includes('password')) {
          addLog(t('messages.passwordError'), 'warning');
        } else if (result.error?.includes('用户取消') || result.error?.includes('cancel')) {
          addLog(t('messages.cancelled'), 'info');
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.ejectError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 全读写
  async function mountAllDevices(): Promise<void> {
    const readOnlyDevices = devices.filter(d => d.isReadOnly && !d.isUnmounted);
    if (readOnlyDevices.length === 0) {
      addLog(t('messages.noDevicesToMount'), 'info');
      return;
    }
    try {
      showLoading(true);
      addLog(t('messages.mountAllStart', { count: readOnlyDevices.length }), 'info');
      let successCount = 0;
      let failCount = 0;
      for (const device of readOnlyDevices) {
        try {
          const result = await electronAPI.mountDevice(device);
          if (result.success) {
            successCount++;
            addLog(`${device.volumeName} ${t('messages.mountSuccess')}`, 'success');
          } else {
            failCount++;
            addLog(`${device.volumeName} ${t('messages.mountError')}: ${result.error || t('messages.unknownError')}`, 'error');
          }
        } catch (error) {
          failCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          addLog(`${device.volumeName} ${t('messages.mountError')}: ${errorMessage}`, 'error');
        }
      }
      if (successCount > 0) {
        addLog(t('messages.mountAllSuccess', { count: successCount }), 'success');
      }
      if (failCount > 0) {
        addLog(t('messages.mountAllError', { count: failCount }), 'warning');
      }
      await new Promise(resolve => setTimeout(resolve, 500));
      await refreshDevices();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.mountError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 全只读
  async function restoreAllToReadOnly(): Promise<void> {
    const readWriteDevices = devices.filter(d => !d.isReadOnly && !d.isUnmounted);
    if (readWriteDevices.length === 0) {
      addLog(t('messages.noDevicesToRestore') || '没有需要还原的设备', 'info');
      return;
    }
    try {
      showLoading(true);
      addLog(t('messages.restoreAllStart', { count: readWriteDevices.length }), 'info');
      let successCount = 0;
      let failCount = 0;
      for (const device of readWriteDevices) {
        try {
          const result = await electronAPI.restoreToReadOnly(device);
          if (result.success) {
            successCount++;
            addLog(`${device.volumeName} ${t('messages.restoreSuccess')}`, 'success');
          } else {
            failCount++;
            addLog(`${device.volumeName} ${t('messages.restoreError')}: ${result.error || t('messages.unknownError')}`, 'error');
          }
        } catch (error) {
          failCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          addLog(`${device.volumeName} ${t('messages.restoreError')}: ${errorMessage}`, 'error');
        }
      }
      if (successCount > 0) {
        addLog(t('messages.restoreAllSuccess', { count: successCount }), 'success');
      }
      if (failCount > 0) {
        addLog(t('messages.restoreAllError', { count: failCount }), 'warning');
      }
      setTimeout(async () => {
        await refreshDevices();
      }, 2000);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.restoreError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 全推出
  async function ejectAllDevices(): Promise<void> {
    if (devices.length === 0) {
      addLog(t('messages.noDevicesToEject') || '没有需要推出的设备', 'info');
      return;
    }
    const confirmed = confirm(`${t('devices.ejectAllConfirm')}\n\n⚠️ ${t('devices.ejectAllConfirmNote') || '请确保没有程序正在使用这些设备'}`);
    if (!confirmed) {
      addLog(t('messages.cancelled'), 'info');
      return;
    }
    try {
      showLoading(true);
      addLog(t('messages.ejectAllStart', { count: devices.length }), 'info');
      let successCount = 0;
      let failCount = 0;
      for (const device of devices) {
        try {
          const result = await electronAPI.ejectDevice(device);
          if (result.success) {
            successCount++;
            addLog(`${device.volumeName} ${t('messages.ejectSuccess')}`, 'success');
          } else {
            failCount++;
            addLog(`${device.volumeName} ${t('messages.ejectError')}: ${result.error || t('messages.unknownError')}`, 'error');
          }
        } catch (error) {
          failCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          addLog(`${device.volumeName} ${t('messages.ejectError')}: ${errorMessage}`, 'error');
        }
      }
      if (successCount > 0) {
        addLog(t('messages.ejectAllSuccess', { count: successCount }), 'success');
      }
      if (failCount > 0) {
        addLog(t('messages.ejectAllError', { count: failCount }), 'warning');
      }
      await refreshDevices();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      addLog(`${t('messages.ejectError')}: ${errorMessage}`, 'error');
    } finally {
      showLoading(false);
    }
  }

  // 自动刷新（优化版：混合检测 - 事件驱动 + 智能轮询备用）
  async function startAutoRefresh(): Promise<void> {
    // 停止旧的轮询
    if (autoRefreshInterval) {
      clearInterval(autoRefreshInterval);
      autoRefreshInterval = null;
    }

    // 注意：每个窗口都需要注册自己的事件监听器
    // 即使混合检测已经全局初始化，每个窗口也需要监听事件

    // 尝试使用混合检测（事件驱动优先）
    try {
      if (electronAPI && typeof electronAPI.startHybridDetection === 'function') {
        const windowType = document.body && document.body.classList.contains('tray-window') ? '托盘窗口' : '主窗口';

        await electronAPI.startHybridDetection((newDevices: any[]) => {
          // 设备变化回调（立即更新，不延迟）
          console.log(`[${windowType}] 设备变化事件触发，设备数量:`, newDevices.length, '设备列表:', newDevices.map(d => d.volumeName));

          // 立即更新设备列表
          devices = newDevices;

          // 强制重新渲染（确保UI更新）
          renderDevices();
          updateDeviceState();

          // 如果是托盘窗口，额外确保更新
          if (document.body && document.body.classList.contains('tray-window')) {
            console.log(`[${windowType}] UI已更新，当前显示设备数量:`, devices.length);
            // 强制触发重排，确保窗口高度正确
            if (window.electronAPI && typeof window.electronAPI.adjustTrayWindowHeightByDeviceCount === 'function') {
              window.electronAPI.adjustTrayWindowHeightByDeviceCount(devices.length);
            }
          }
        });

        hybridDetectionStarted = true;
        console.log(`✅ [混合检测] 事件监听器已注册 - ${windowType}`);

        // 监听窗口可见性变化
        document.addEventListener('visibilitychange', () => {
          if (electronAPI && typeof electronAPI.updateWindowVisibility === 'function') {
            electronAPI.updateWindowVisibility(!document.hidden);
          }

          // 窗口变为可见时，立即强制刷新设备列表
          if (!document.hidden) {
            setTimeout(() => {
              refreshDevices(true);
            }, 100);
          }
        });

        return;
      }
    } catch (error) {
      console.warn('[混合检测] 启动失败，降级到轮询模式:', error);
    }

    // 降级到智能轮询（如果混合检测不可用）
    console.log('⚠️ [混合检测] 使用智能轮询模式');
    hybridDetectionStarted = false;

    let currentInterval = 500; // 初始0.5秒（加快初始检测）
    let consecutiveChanges = 0;
    let lastDeviceHash = '';

    const poll = async () => {
      try {
        const oldDeviceCount = devices.length;
        const oldDeviceHash = JSON.stringify(devices.map(d => ({ disk: d.disk, isMounted: d.isMounted, isReadOnly: d.isReadOnly })));

        await refreshDevices(true); // 强制刷新（跳过缓存）

        const newDeviceCount = devices.length;
        const newDeviceHash = JSON.stringify(devices.map(d => ({ disk: d.disk, isMounted: d.isMounted, isReadOnly: d.isReadOnly })));
        const hasChanged = oldDeviceHash !== newDeviceHash;

        // 根据状态调整轮询间隔
        if (hasChanged) {
          consecutiveChanges++;
          currentInterval = 1000; // 变化后使用1秒高频（加快响应）
        } else {
          if (consecutiveChanges > 0) {
            consecutiveChanges = Math.max(0, consecutiveChanges - 1);
          }

          if (newDeviceCount === 0) {
            currentInterval = 30000; // 无设备：30秒
          } else if (consecutiveChanges === 0) {
            currentInterval = 5000; // 稳定状态：5秒（减少到5秒）
          }
        }

        if (consecutiveChanges > 3) {
          consecutiveChanges = 0;
          currentInterval = 5000; // 减少到5秒
        }

        const isVisible = !document.hidden;
        if (!isVisible) {
          currentInterval = 60000; // 窗口不可见：60秒
        }

        lastDeviceHash = newDeviceHash;
        autoRefreshInterval = setTimeout(poll, currentInterval);
      } catch (error) {
        console.error('[智能轮询] 检测失败:', error);
        autoRefreshInterval = setTimeout(poll, 5000); // 减少到5秒
      }
    };

    poll();
  }

  // 更新设备状态（用于日志）
  function updateDeviceState(): void {
    const currentDeviceCount = devices.length;
    const readOnlyCount = devices.filter(d => d.isReadOnly).length;
    const currentState = `${currentDeviceCount}-${readOnlyCount}`;

    const stateChanged = currentDeviceCount !== lastDeviceCount || currentState !== lastDeviceState;

    if (devices.length === 0) {
      if (stateChanged) {
        addLog(t('messages.noDevicesDetected'), 'info');
      }
    } else {
      const readWriteCount = devices.length - readOnlyCount;

      if (readOnlyCount > 0) {
        if (stateChanged) {
          if (readWriteCount > 0) {
            addLog(t('messages.devicesDetected', { count: devices.length, readOnly: readOnlyCount, readWrite: readWriteCount }), 'info');
          } else {
            addLog(t('messages.devicesDetectedAllReadOnly', { count: devices.length }), 'warning');
          }
        }
      } else {
        if (stateChanged) {
          addLog(t('messages.devicesDetectedAllReadWrite', { count: devices.length }), 'success');
        }
      }
    }

    lastDeviceCount = currentDeviceCount;
    lastDeviceState = currentState;
  }

  // 初始化
  // 将 refreshDevices 暴露到 window 对象，供外部调用
  (window as any).refreshDevices = refreshDevices;
  (window as any).renderDevices = renderDevices;

  // 检查初始状态，如果是托盘窗口，立即添加类
  if (document.body && !document.body.classList.contains('tray-window')) {
    // 检查窗口特征来判断是否是托盘窗口（无边框、固定大小等）
    // 但更可靠的方法是在 window-manager.ts 中添加类
  }

  // 监听 body 类变化，当添加 tray-window 类时重新渲染
  if (typeof MutationObserver !== 'undefined') {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const target = mutation.target as HTMLElement;
          if (target.classList.contains('tray-window')) {
            // 延迟一点时间，确保类已完全添加
            setTimeout(() => {
              if (typeof refreshDevices === 'function') {
                refreshDevices();
              }
            }, 100);
          }
        }
      });
    });

    // 立即开始观察（如果 body 已存在）
    if (document.body) {
      observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
      // 如果已经是托盘窗口，立即触发渲染
      if (document.body.classList.contains('tray-window')) {
        setTimeout(() => {
          if (typeof refreshDevices === 'function') {
            refreshDevices();
          }
        }, 100);
      }
    }

    // 在 DOMContentLoaded 后也确保观察
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        if (document.body) {
          observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
          // 如果已经是托盘窗口，立即触发渲染
          if (document.body.classList.contains('tray-window')) {
            setTimeout(() => {
              if (typeof refreshDevices === 'function') {
                refreshDevices();
              }
            }, 100);
          }
        }
      });
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    // 更新按钮文本（国际化）
    const updateButtonTexts = () => {
      const AppUtils = (window as any).AppUtils;
      if (!AppUtils || !AppUtils.I18n || !AppUtils.I18n.t) {
        return;
      }
      const t = AppUtils.I18n.t;

      // 测试翻译是否已加载（通过尝试翻译一个已知的键）
      const testTranslation = t('devices.title');
      if (testTranslation === 'devices.title') {
        // 翻译数据还未加载，延迟重试
        setTimeout(updateButtonTexts, 100);
        return;
      }

      // showMainWindowBtn 现在是图标按钮，不需要更新文本
      if (mountAllBtn) {
        mountAllBtn.textContent = t('devices.mountAll');
      }
      if (restoreAllReadOnlyBtn) {
        restoreAllReadOnlyBtn.textContent = t('devices.restoreAllReadOnly');
      }
      if (ejectAllBtn) {
        ejectAllBtn.textContent = t('devices.ejectAll');
      }
      // autoMountBtn 现在是图标按钮，不需要更新文本
    };

    // 等待 i18n 初始化完成后再更新文本
    const waitForI18n = () => {
      const AppUtils = (window as any).AppUtils;
      if (AppUtils && AppUtils.I18n && AppUtils.I18n.t) {
        updateButtonTexts();
        // 监听语言变化，重新更新文本（修复：使用事件监听而不是回调）
        window.addEventListener('languageChanged', () => {
          // 延迟一点确保翻译已加载
          setTimeout(() => {
            updateButtonTexts();
            // 重新渲染设备列表以更新按钮文本
            renderDevices();
          }, 100);
        });
      } else {
        // 如果 i18n 还未初始化，延迟重试（最多等待 5 秒）
        let retryCount = 0;
        const maxRetries = 50;
        const retry = () => {
          retryCount++;
          if (retryCount < maxRetries) {
            setTimeout(() => {
              const AppUtils = (window as any).AppUtils;
              if (AppUtils && AppUtils.I18n && AppUtils.I18n.t) {
                updateButtonTexts();
              } else {
                retry();
              }
            }, 100);
          }
        };
        retry();
      }
    };
    waitForI18n();

    // 功能按钮
    if (autoMountBtn) {
      let autoMountEnabled = false;

      // 从设置读取自动挂载配置
      const loadAutoMountSetting = async () => {
        try {
          if (electronAPI.getSettings) {
            const settings = await electronAPI.getSettings();
            if (settings && typeof settings.autoMount === 'boolean') {
              autoMountEnabled = settings.autoMount;
              updateAutoMountButtonState();
            }
          }
        } catch (e) {
          // 静默处理
        }
      };

      // 更新按钮状态
      const updateAutoMountButtonState = () => {
        if (autoMountEnabled) {
          autoMountBtn.classList.add('active');
        } else {
          autoMountBtn.classList.remove('active');
        }
      };

      // 初始加载
      loadAutoMountSetting();

      // 监听设置变化事件
      if (electronAPI.onSettingsChange) {
        electronAPI.onSettingsChange((settings: any) => {
          if (settings && typeof settings.autoMount === 'boolean') {
            autoMountEnabled = settings.autoMount;
            updateAutoMountButtonState();
          }
        });
      }

      autoMountBtn.addEventListener('click', async () => {
        try {
          autoMountEnabled = !autoMountEnabled;
          updateAutoMountButtonState();
          if (electronAPI.saveSettings) {
            await electronAPI.saveSettings({ autoMount: autoMountEnabled });
          }
        } catch (e) {
          // 静默处理
        }
      });
    }
    if (showMainWindowBtn) {
      showMainWindowBtn.addEventListener('click', async () => {
        try {
          if (electronAPI.showMainWindow) {
            await electronAPI.showMainWindow();
          }
        } catch (error) {
          console.error('显示主窗口失败:', error);
        }
      });
    }
    if (refreshDevicesBtn) {
      refreshDevicesBtn.addEventListener('click', async () => {
        // 禁用按钮，防止重复点击
        if (refreshDevicesBtn) {
          refreshDevicesBtn.disabled = true;
          const originalHTML = refreshDevicesBtn.innerHTML;
          const refreshingText = t('tray.refreshing') || '刷新中...';
          refreshDevicesBtn.innerHTML = `<img src="../imgs/svg/refresh.svg" alt="" class="btn-icon">`;
          refreshDevicesBtn.title = refreshingText;
          try {
            // 强制刷新设备列表（跳过缓存）
            await refreshDevices(true);
          } catch (error) {
            console.error('刷新设备列表失败:', error);
            await addLog('刷新设备列表失败: ' + (error instanceof Error ? error.message : String(error)), 'error');
          } finally {
            // 恢复按钮状态
            if (refreshDevicesBtn) {
              refreshDevicesBtn.disabled = false;
              const refreshText = t('devices.refreshDevices') || '刷新';
              refreshDevicesBtn.innerHTML = `<img src="../imgs/svg/refresh.svg" alt="" class="btn-icon">`;
              refreshDevicesBtn.title = refreshText;
            }
          }
        }
      });
    }
    if (mountAllBtn) {
      mountAllBtn.addEventListener('click', mountAllDevices);
    }
    if (restoreAllReadOnlyBtn) {
      restoreAllReadOnlyBtn.addEventListener('click', restoreAllToReadOnly);
    }
    if (ejectAllBtn) {
      ejectAllBtn.addEventListener('click', ejectAllDevices);
    }

    // 自动刷新
    refreshDevices();
    startAutoRefresh();

    // 监听主题变化
    if (window.electronAPI && window.electronAPI.onThemeChange) {
      window.electronAPI.onThemeChange((isLightMode: boolean) => {
        // 更新body的class
        if (isLightMode) {
          document.body.classList.add('light-theme');
        } else {
          document.body.classList.remove('light-theme');
        }
      });
    }

    // 初始化主题
    try {
      const savedTheme = localStorage.getItem('app-theme');
      if (savedTheme === 'light') {
        document.body.classList.add('light-theme');
      }
    } catch (e) {
      // 静默处理
    }

    // 清理
    window.addEventListener('beforeunload', () => {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
    });
  });
})();
